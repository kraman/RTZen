
package edu.uci.ece.zen.poa;


/**
 * This Class implements the POA Current Interface in the Portable
 * Server Module. The Default Servant uses the Current Object to query
 * the Object it is incarnating. The Current Objects are thread
 * specific and have no locking overhead. Also this class should not
 * maintain any state and should get all the state information from
 * the current thread.
 * @author Arvind S. Krishna
 */
public class Current extends org.omg.CORBA.LocalObject
    implements org.omg.PortableServer.Current {
    private Current() {}
/**
 * This method creates a nre Current object.
 * @return New Current object.
 *
 */
    public static Current currentInit() {
        return new Current();
    }

/**
 * This methor returns the POA associated with the current object.
 * @exception org.omg.PortableServer.CurrentPackage.NoContext exception is thrown if no context is associated with the object.
 * @return POA assocaited with the current object.
 */
     public org.omg.PortableServer.POA get_POA()
        throws org.omg.PortableServer.CurrentPackage.NoContext {
        ThreadSpecificPOACurrent obj = (ThreadSpecificPOACurrent) getInvocationContext();

        return obj.getPOA();
    }

    /**
     * From the TSS POACurrent the Object key is got. The Entire byte array
     * should be returned by this function that would have the full Object
     * id generated by the POA. Use the Id function that returns the object
     * id and not the Object Key.
     * @exception org.omg.PortableServer.CurrentPackage.NoContex exception is thrown if no context is associated with the object.
     * @return The object id identifying the object in whose context this method is called.
     */

    public byte[] get_object_id() throws
                org.omg.PortableServer.CurrentPackage.NoContext {
        ThreadSpecificPOACurrent obj = (ThreadSpecificPOACurrent) getInvocationContext();

        return obj.getObjectKey().getId();
    }

    /**
     * Use the POA that made the call to get the reference of the Object
     * The Spec says that the reference is not gureanteed to be the same as'
     * the one that the client used to make the request. In our case it could
     * be the same.
     * @exception org.omg.PortableServer.CurrentPackage.NoContex exception is thrown if no context is associated with the object.
     * @return Returns the reference to the object in current context.
     */

    public org.omg.CORBA.Object get_reference() throws
                org.omg.PortableServer.CurrentPackage.NoContext {

        ThreadSpecificPOACurrent obj = (ThreadSpecificPOACurrent) getInvocationContext();

        ObjectKey okey = obj.getObjectKey();
        edu.uci.ece.zen.poa.POA poa = (POA) get_POA();

        org.omg.PortableServer.Servant servant = this.get_servant();
        String[] temp = servant._all_interfaces(poa, okey.getId());

        return poa.create_reference_with_object_key(okey, temp[0]);
    }

    /**
     * rerturns the reference to the servant in whose context the operation
     * was called.
     * @exception org.omg.PortableServer.CurrentPackage.NoContex exception is thrown if no context is associated with the object.
     * @return The reference to the servant that hosts the object.
     */

    public org.omg.PortableServer.Servant get_servant() throws
                org.omg.PortableServer.CurrentPackage.NoContext {
        ThreadSpecificPOACurrent obj = (ThreadSpecificPOACurrent) getInvocationContext();

        return obj.getServant();
    }

    private Object getInvocationContext() throws
                org.omg.PortableServer.CurrentPackage.NoContext {
        ThreadSpecificPOACurrent current = POATSS.tss.getCurrent();

        if (current == null) {
            throw new org.omg.PortableServer.CurrentPackage.NoContext();
        } else {
            return current;
        }

    }
}
