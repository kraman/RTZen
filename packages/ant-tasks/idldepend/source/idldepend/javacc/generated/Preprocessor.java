/* Generated By:JavaCC: Do not edit this line. Preprocessor.java */
package idldepend.javacc.generated;

import idldepend.javacc.Prepreprocessor;
import idldepend.javacc.PreprocessorInterface;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class Preprocessor implements PreprocessorConstants {

  /**
   * AddedInfo is any number of new definition (or undefinitions) to be done
   */
  public Preprocessor(File file, String addedInfo, PreprocessorInterface controller)
      throws ParseException, IOException{
    this(new Prepreprocessor(file, controller, addedInfo));
    this.controller=controller;
  }

  private Preprocessor(Prepreprocessor prepreprocessor)
      throws ParseException, IOException{
    this(prepreprocessor.getFilteredInput());
    this.prepreprocessor=prepreprocessor;
  }

  public void parseInput() throws ParseException {
    while(parse())
      ;
  }

  public void stopParsing(){
    prepreprocessor.stopTask();
  }

  public int getReadLine() {
    return line;
  }

  public String getReadFile() {
    return file;
  }

  /**
   * line directive issued by the prepreprocessor
   */
  private void preplineDirective(String directive) throws ParseException{
    int space=directive.indexOf(' ',9);
    file=directive.substring(space+1);
    line=Integer.valueOf(directive.substring(9,space)).intValue();
    if (firstInclude) {
      firstInclude=false;
    }
    else {
      if (line==0) {
        controller.includingFile(file);
      }
      else {
        controller.fileIncluded();
      }
    }
    passLine(line, "\"" + file + "\"");
  }

  /**
   * line directive not issued by the prepreprocessor, just found on the
   * original file
   * @param withLine true if the directive starts with #line
   */
  private void lineDirective(boolean withLine,boolean withFile,String directive)
       throws ParseException {

    String toUse = directive.substring(withLine? 6 : 2).trim();
    int space=-1;
    if (withFile) {
      int startFile = toUse.indexOf('"');
      file=toUse.substring(startFile);
      space=toUse.indexOf(' ');
      int tab=toUse.indexOf('\t');
      if ((space==-1) || ((tab!=-1) && (tab<space))) {
        space=tab;
      }
    }
    if (space==-1) {
      line=Integer.valueOf(toUse).intValue();
    }
    else {
      line=Integer.valueOf(toUse.substring(0,space)).intValue();
    }
    passLine(line, file);
  }

  private void passLine(int number, String file)
        throws ParseException {

    StringBuffer buffer = new StringBuffer("#line ");
    buffer.append(number).append(' ').append(file);
    Token read = new Token();
    read.image=buffer.toString();
    read.kind=OTHER;
    controller.readToken(read);
  }

  PreprocessorInterface controller;
  Prepreprocessor prepreprocessor;
  int line;
  String file="preprocessor";
  boolean firstInclude=true;
  static Token prEOL = new Token();
  static Token prPragma = new Token();
  static{
    prEOL.kind=EOL;
    prEOL.image="\n";
    prPragma.image="#pragma";
    prPragma.kind=OTHER;
  }

  final public boolean parse() throws ParseException {
  boolean ret=true;
    line++;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PREPLINE:
    case LINE:
    case LINE2:
    case DEFINE:
    case UNDEF:
    case IFDEF:
    case IFNDEF:
    case IF:
    case ENDIF:
    case ELSE:
    case ELIF:
    case ERROR:
    case PRAGMA:
    case INCLUDEQ:
    case LINE3:
    case LINE4:
    case UNKNOWN:
      preprocessorLine();
      break;
    case 0:
    case EOL:
    case LEFTPAR:
    case RIGHTPAR:
    case COMMA:
    case SPECIAL:
    case STRING:
    case CHAR:
    case SPACE:
    case ID:
    case OTHER:
      ret = normalLine();
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    controller.readToken(prEOL);
    {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public void preprocessorLine() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PREPLINE:
      preplineLine();
      break;
    case LINE:
      lineLine();
      break;
    case LINE2:
      lineWithoutFileLine();
      break;
    case LINE3:
      lineWithoutLineLine();
      break;
    case LINE4:
      lineWithoutLineWithoutFileLine();
      break;
    case DEFINE:
      defineLine();
      break;
    case UNDEF:
      undefLine();
      break;
    case IFDEF:
      ifDefLine();
      break;
    case IFNDEF:
      ifNdefLine();
      break;
    case IF:
      ifLine();
      break;
    case ENDIF:
      endifLine();
      break;
    case ELSE:
      elseLine();
      break;
    case ELIF:
      elifLine();
      break;
    case INCLUDEQ:
      questionOnIncludeLine();
      break;
    case ERROR:
      errorLine();
      break;
    case PRAGMA:
      pragmaLine();
      break;
    case UNKNOWN:
      unknownLine();
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void questionOnIncludeLine() throws ParseException {
    jj_consume_token(INCLUDEQ);
    endOfLine();
                           --line;controller.verifyFileInclusion();
  }

  final public void endifLine() throws ParseException {
    jj_consume_token(ENDIF);
    endOfLine();
                        controller.alternateEvaluationLevel(true);
  }

  final public void elseLine() throws ParseException {
    jj_consume_token(ELSE);
    endOfLine();
                       controller.alternateEvaluationLevel(false);
  }

  final public void ifLine() throws ParseException {
    jj_consume_token(IF);
    controller.startEvaluation(false);
    readTokensInLine();
    controller.completeEvaluation(false);
  }

  final public void elifLine() throws ParseException {
    jj_consume_token(ELIF);
    controller.startEvaluation(true);
    readTokensInLine();
    controller.completeEvaluation(true);
  }

  final public void ifDefLine() throws ParseException {
   String id;
    jj_consume_token(IFDEF);
    id = readId();
                        controller.simpleEvaluation(id,true);
  }

  final public void ifNdefLine() throws ParseException {
   String id;
    jj_consume_token(IFNDEF);
    id = readId();
                         controller.simpleEvaluation(id,false);
  }

  final public void preplineLine() throws ParseException {
  Token t;
    t = jj_consume_token(PREPLINE);
     preplineDirective(t.toString());
  }

  final public void lineLine() throws ParseException {
  Token t;
    t = jj_consume_token(LINE);
    lineDirective(true, true, t.toString());
  }

  final public void lineWithoutFileLine() throws ParseException {
  Token t;
    t = jj_consume_token(LINE2);
     lineDirective(true, false, t.toString());
  }

  final public void lineWithoutLineLine() throws ParseException {
  Token t;
    t = jj_consume_token(LINE3);
     lineDirective(false, true, t.toString());
  }

  final public void lineWithoutLineWithoutFileLine() throws ParseException {
  Token t;
    t = jj_consume_token(LINE4);
     lineDirective(false, false, t.toString());
  }

  final public void pragmaLine() throws ParseException {
    jj_consume_token(PRAGMA);
    controller.readToken(prPragma);
    readTokensInLine();
  }

  final public void unknownLine() throws ParseException {
    jj_consume_token(UNKNOWN);
    controller.storeTokens(true);
    readTokensInLine();
    controller.storeTokens(false);
    controller.unknownDirective();
  }

  final public void errorLine() throws ParseException {
   Token token;
    token = jj_consume_token(ERROR);
    controller.storeTokens(true);
    readTokensInLine();
    controller.storeTokens(false);
    controller.errorDirective();
  }

  final public void undefLine() throws ParseException {
   String id;
    jj_consume_token(UNDEF);
    id = readId();
                        controller.undefineMacro(id);
  }

  final public void defineLine() throws ParseException {
  Token def;
    jj_consume_token(DEFINE);
    label_1:
    while (true) {
      jj_consume_token(SPACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
    }
    def = jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTPAR:
      complexMacro(def);
      break;
    case 0:
    case EOL:
    case RIGHTPAR:
    case COMMA:
    case SPECIAL:
    case STRING:
    case CHAR:
    case SPACE:
    case ID:
    case OTHER:
      simpleMacro(def);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void complexMacro(Token def) throws ParseException {
  List params=new ArrayList();
    jj_consume_token(LEFTPAR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SPACE:
    case ID:
      macroParameters(params);
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    jj_consume_token(RIGHTPAR);
      controller.defineMacro(def.toString(), params);
    readTokensInLine();
      controller.macroDefined();
  }

  final public void simpleMacro(Token def) throws ParseException {
   controller.defineMacro(def.toString());
    readTokensInLine();
    controller.macroDefined();
  }

  final public void macroParameters(List in) throws ParseException {
   Token t;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      jj_consume_token(SPACE);
    }
    t = jj_consume_token(ID);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      jj_consume_token(SPACE);
    }
                                  in.add(t);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_5;
        }
        jj_consume_token(SPACE);
      }
      t = jj_consume_token(ID);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPACE:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_6;
        }
        jj_consume_token(SPACE);
      }
                                         in.add(t);
    }
  }

  final public boolean normalLine() throws ParseException {
  boolean ret=true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EOL:
      jj_consume_token(EOL);
      break;
    case 0:
      jj_consume_token(0);
            ret=false;
      break;
    case LEFTPAR:
    case RIGHTPAR:
    case COMMA:
    case SPECIAL:
    case STRING:
    case CHAR:
    case SPACE:
    case ID:
    case OTHER:
      readToken();
      ret = readTokensInLine();
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
   {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public String readId() throws ParseException {
Token token;
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_7;
      }
      jj_consume_token(SPACE);
    }
    token = jj_consume_token(ID);
    endOfLine();
                                     {if (true) return token.toString();}
    throw new Error("Missing return statement in function");
  }

  final public boolean readTokensInLine() throws ParseException {
  boolean ret=true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EOL:
      jj_consume_token(EOL);
      break;
    case 0:
      jj_consume_token(0);
            ret=false;
      break;
    case LEFTPAR:
    case RIGHTPAR:
    case COMMA:
    case SPECIAL:
    case STRING:
    case CHAR:
    case SPACE:
    case ID:
    case OTHER:
      readToken();
      ret = readTokensInLine();
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
   {if (true) return ret;}
    throw new Error("Missing return statement in function");
  }

  final public void readToken() throws ParseException {
   Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      t = jj_consume_token(ID);
      break;
    case STRING:
      t = jj_consume_token(STRING);
      break;
    case LEFTPAR:
      t = jj_consume_token(LEFTPAR);
      break;
    case COMMA:
      t = jj_consume_token(COMMA);
      break;
    case RIGHTPAR:
      t = jj_consume_token(RIGHTPAR);
      break;
    case SPECIAL:
      t = jj_consume_token(SPECIAL);
      break;
    case SPACE:
      t = jj_consume_token(SPACE);
      break;
    case CHAR:
      t = jj_consume_token(CHAR);
      break;
    case OTHER:
      t = jj_consume_token(OTHER);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    controller.readToken(t);
  }

  final public void endOfLine() throws ParseException {
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPACE:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_8;
      }
      jj_consume_token(SPACE);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
      jj_consume_token(0);
      break;
    case EOL:
      jj_consume_token(EOL);
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  public PreprocessorTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[16];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x1ffffffd,0x7fffc,0x4000000,0x1ff80001,0xc000000,0x4000000,0x4000000,0x400000,0x4000000,0x4000000,0x1ff80001,0x4000000,0x1ff80001,0x1ff00000,0x4000000,0x80001,};
   }

  public Preprocessor(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new PreprocessorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public Preprocessor(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new PreprocessorTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public Preprocessor(PreprocessorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  public void ReInit(PreprocessorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 16; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[29];
    for (int i = 0; i < 29; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 16; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 29; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
